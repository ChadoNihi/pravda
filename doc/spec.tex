\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{dcolumn}
\usepackage{tabularx}
\usepackage{scrextend}
\usepackage{url}
\usepackage{mathabx}

\title{B* Smart-contracts Engine Specification}
\author{Aleksey Fomkin}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

As part of the Mytime Project, BSCE is designed to solve challenges of the game industry in section of decentralization. The purpose of BSCE is programmatic management of global state of the network. We're offering minimalistic deterministic virtual machine and runtime library for managed execution of smart-contracts.

In our work we're focusing on simplicity and extensibility. We don't set ourselves a task to invent something new, but using solid foundation of computer science we consider requirements of the network.

This document specifies memory and execution model, bytecode format, start-contracts interop and definition of standard library (including procedures and data types). Also this document defines gas-economy. The document \textit{doesn't} consider issues of blockchain, consensus, network of storage. 

\section{Execution model}

\subsection{General}

BSCE is a stack-based virtual machine. All data is represented by string, so "machine word" is a string. BSCE can store words in a managed heap. Heap is inaccessible for raw reads/writes and fully managed by runtime. Heap has map-like interface where key is string of four bytes and value is an arbitrary string. 

Persistence is an integral part of BSCE which is a representation of a global state of the network. Persistent state has map-like interface as the heap. The difference is programmer can use arbitrary string as a key.

Code can be executed.
\subsection{Execution scopes}

Launched code is named execution. There are two execution scopes: transaction and smart-contract. If launched code is placed in a transaction it has \textit{transaction scope}. Similarly if launched code is placed in a smart-contract it has \textit{smart-contract scope}. Every execution has its own heap. 

Execution in transactions scope has not persistent storage but has its own stack. Execution in smart-contacts scope inherits a stack from an execution which launches it. Also it has persistent storage shared between all the executions of the smart-contract.

\subsection{Transaction isolation}

As noted above persistence is an integral part of BSCE. Executions can read and write to the persistent storage. BSCE supports parallel execution of the same smart-contacts. It means concurrent access to the stored data. According to this requirement we need to provide highest level of consistency so transactions is isolated serializable\cite{transaction-isolation}. 

\section{Bytecode}

BVM executes bytecode in the format described below. Every program is a linear sequence of \textit{opcodes}. Any opcode is represented by one byte. Exception is "PUSHX" opcode which is represented by one byte for opcode itself and a word to represent a constant.

First 3 bits of the word encode length. This is the length of the length of the encoded data. For example, $256$ bytes of the data are encoded by the word of $258$ bytes , which are

$$\underbrace{010}_{3~bits}\underbrace{00001~00000000}_{5~bits~+~1~byte} \underbrace{\cdots}_{256~bytes} $$

If the length of the length is 0 the data is encoded by the rest $5$ bits of the byte.

\subsection{Control}
\begin{tabularx}{\textwidth}{ c l c c p{7cm} }
\textbf{Code} & \textbf{Mnemonic} & \textbf{$\Uparrow$} & \textbf{$\Downarrow$} & \textbf{Description} \\
\hline
0x00 & STOP & $0$ & $0$ & Stops current execution. \\
\hline
0x01 & JUMP & $1$ & $0$ & Alters program execution counter to value of first item of the stack. \\
\hline
0x02 & JUMPI & $2$ & $0$ & If value in head of stack is greater than 0 then alters program execution counter to value of second item in the stack.  \\
\hline
0x03 & RUN & $1$ & $0$ & Launches smart-contract from address given in the first item of the stack.  \\
\hline
0x04 & CALL & $1$ & $0$ & Firstly, it pushes current program counter to the separate stack (so called \emph{call stack}). Then it alters program execution counter to the value of the first item of the stack.  \\
\hline
0x05 & RET & $0$ & $0$ & Alters program execution counter to the value of the first item of the call stack (see CALL opcode).  \\
\hline
0x06 & PCALL & $1$ & $0$ & Executes a smart contract with the address corresponding to the top value of the stack.  \\

\end{tabularx}

\subsection{Stack}
\begin{tabularx}{\textwidth}{ c l c c p{7cm} }
\textbf{Code} & \textbf{Mnemonic} & \textbf{$\Uparrow$} & \textbf{$\Downarrow$} & \textbf{Description} \\
\hline
0x10 & POP & $1$ & $0$ & Removes first item from the stack. \\
\hline
0x11 & PUSHX & $0$ & $1$ & Pushes the word following the opcode to the stack. \\
\hline
0x22 & DUP1 & $1$ & $2$ & Duplicates first item of the stack. \\
\vdots & \vdots & \vdots & \vdots \\
0x31 & DUP16 & $1$ & $2$ & Duplicates sixteenth item of the stack. \\
\hline
0x32 & DUPN & $1$ & $n$ & Duplicates $n-1$ item of the stack where $n$ is first item in stack. \\
\hline
0x23 & SWAP1 & $2$ & $2$ & Swaps first two items in the stack. \\
\vdots & \vdots & \vdots & \vdots \\
0x42 & SWAP16 & $2$ & $2$ & Swaps first and sixteenth items in the stack. \\
\hline
\end{tabularx}

\subsection{Heap}
\begin{tabularx}{\textwidth}{ c l c c p{7cm} }
\textbf{Code} & \textbf{Mnemonic} & \textbf{$\Uparrow$} & \textbf{$\Downarrow$} & \textbf{Description} \\
\hline
0x43 & MPUT & $1$ & $1$ & Saves first item in stack to the heap. Pushes address of the item to the heap. \\
\hline
0x44 & MGET & $1$ & $1$ & Pushes an item saved in heap corresponding to address given in first item of the stack.  \\
\hline
\end{tabularx}

\subsection{Persistent storage}
\begin{tabularx}{\textwidth}{ c l c c p{7cm} }
\textbf{Code} & \textbf{Mnemonic} & \textbf{$\Uparrow$} & \textbf{$\Downarrow$} & \textbf{Description} \\
\hline
0x50 & SPUT & $1$ & $1$ & Saves first item in the stack to the persistent storage. Pushes address of the item to the heap. \\
\hline
0x51 & SGET & $1$ & $1$ & Pushes an item saved in persistent storage corresponding to address given in a first item of the stack.  \\
\hline
0x52 & SDROP & $1$ & $1$ & Removes item corresponding to address given in a first item of the stack from the persistent storage.  \\
\hline
\end{tabularx}

\subsection{Int32 operations}
\begin{tabularx}{\textwidth}{ c l c c p{7cm} }
\textbf{Code} & \textbf{Mnemonic} & \textbf{$\Uparrow$} & \textbf{$\Downarrow$} & \textbf{Description} \\
\hline
0x60 & I32ADD & $2$ & $1$ & Add two int32 from the stack. \\
\hline
0x61 & I32MUL & $2$ & $1$ & Multiply int32 decimals from the stack. \\
\hline
0x62 & I32DIV & $2$ & $1$ & Divide two int32 from the stack. \\
\hline
0x63 & I32MOD & $2$ & $1$ & Finds the remainder after division of two int32 from the stack. \\
\hline
\end{tabularx}

\begin{thebibliography}{9}

\bibitem{transaction-isolation} Understanding Isolation Levels \url{https://docs.microsoft.com/en-us/sql/connect/jdbc/understanding-isolation-levels}
\end{thebibliography}

\end{document}

